pub mod limit;
pub mod order;

use limit::*;
use order::*;
use ordered_float::OrderedFloat;
use serde::{Deserialize, Serialize};

// use std::fmt::{self, Debug};
use std::ptr::{self};
use std::sync::atomic::{AtomicPtr, Ordering::*};
use std::sync::Arc;

use crossbeam_skiplist::SkipMap;
use dashmap::DashMap;

/// Enum used for responsding to the matching engine when everything work's out well
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum LOBResponse {
    Inserted(String, f64, u32, OrderType),
    Executed(String, f64, f64, u32, OrderStatus, OrderType),
    Cancelled(Box<Order>),
}

/// Enum used for responsding to the matching engine when there's an error.
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum LOBError {
    InvalidOrder,
    LimitNotFound,
    OrderNotFound,
    MatchingEngineError,
}

///This struct is basically the limit order book and the data structure of the fields are concurrent skip_lists
/// [`LimitOrderBook::bid_list`] and [`LimitOrderBook::ask_list`] and dashmaps (which are the concurrent version of hashmaps)
/// [`LimitOrderBook::bmap`],[`LimitOrderBook::amap`] and [`LimitOrderBook::omap`] and the [`LimitOrderBook`] holds the pointer
/// to the [`LimitOrderBook::best_bid`] (which is the greatest limit price from the buy_list) and [`LimitOrderBook::best_ask`]
/// (which is the smallest limit price from the ask_list). This complex struct will be used by the message queue which
/// serves the job of each message by spawing new thread for specific task.
pub struct LimitOrderBook {
    pub id: i32,
    ///  Unique identification of Limit order book.
    bid_list: Arc<SkipMap<OrderedFloat<f64>, AtomicPtr<Limit>>>, // skip-list for the ASK side.
    ask_list: Arc<SkipMap<OrderedFloat<f64>, AtomicPtr<Limit>>>, // skip-list for the BID side.
    bmap: Arc<DashMap<OrderedFloat<f64>, AtomicPtr<Limit>>>,     // BID type limit node's DashMap.
    amap: Arc<DashMap<OrderedFloat<f64>, AtomicPtr<Limit>>>,     // ASK type limit node's DashMap.
    omap: Arc<DashMap<String, AtomicPtr<Order>>>, // hashmap for Orders and since order are identified using there
    // sequence number we don't need the ask and bid order's hashmap.
    pub best_bid: AtomicPtr<Order>, // atomic pointer to the best BID order.
    pub best_ask: AtomicPtr<Order>, // atomic pointer to the best ASK order.
}

impl LimitOrderBook {
    pub fn new(id: i32) -> LimitOrderBook {
        LimitOrderBook {
            id,
            bid_list: Arc::new(SkipMap::new()),
            ask_list: Arc::new(SkipMap::new()),
            bmap: Arc::new(DashMap::new()),
            amap: Arc::new(DashMap::new()),
            omap: Arc::new(DashMap::new()),
            best_bid: AtomicPtr::new(ptr::null_mut()),
            best_ask: AtomicPtr::new(ptr::null_mut()),
        }
    }

    /// This method is supposed to insert the [`Order`] via atomic steps.
    /// First of all the order needs the [`Order::id`] which is generated by the engine and then
    /// if the order is not present already in the [`LimitOrderBook::omap`] then and then only the new order is inserted.
    /// Once the order is inserted in the [`LimitOrderBook::omap`] and the relavent skip list , i.e [`LimitOrderBook::bid_list`] or [`LimitOrderBook::ask_list`]
    /// which is decided based on the [`OrderType`]. So after this step one final thing remains which is updating the [`LimitOrderBook::best_bid`] or [`LimitOrderBook::best_ask`]
    /// based on the [`OrderType`] and if anything went wrong then this method returns [`LOBError`] wrapped on the [`Result::Err`] enum , else it returns [`LOBResponse`] as an [`Result::Ok`]
    pub fn insert_order(
        &self,
        id: String,
        price: f64,
        shares: u32,
        order_type: OrderType,
    ) -> Result<LOBResponse, LOBError> {
        let new_order = Box::into_raw(Box::new(Order::new(id.clone(), order_type, price, shares)));
        let (map, list);

        if self.omap.contains_key(&id) {
            return Err(LOBError::InvalidOrder);
        }

        match order_type {
            OrderType::BID => {
                map = self.bmap.clone();
                list = self.bid_list.clone();
            }
            OrderType::ASK => {
                map = self.amap.clone();
                list = self.ask_list.clone();
            }
        }

        let limit = map
            .entry(OrderedFloat(price))
            .or_insert_with(|| {
                let limit = Box::into_raw(Box::new(Limit::new(price, order_type)));
                list.insert(OrderedFloat(price), AtomicPtr::new(limit));
                AtomicPtr::new(limit)
            })
            .load(Acquire);

        if let Some(limit) = unsafe { limit.as_ref() } {
            limit.insert(new_order);
            limit.volume.fetch_add(shares, SeqCst);
        }

        self.omap.insert(id.clone(), AtomicPtr::new(new_order));

        match order_type {
            OrderType::BID => {
                if let Err(existing_order) =
                    self.best_bid
                        .compare_exchange(ptr::null_mut(), new_order, Release, Acquire)
                {
                    if unsafe { &*existing_order }.price < price {
                        self.best_bid.store(new_order, Release);
                    }
                }
            }
            _ => {
                if let Err(existing_order) =
                    self.best_ask
                        .compare_exchange(ptr::null_mut(), new_order, Release, Acquire)
                {
                    if unsafe { &*existing_order }.price > price {
                        self.best_ask.store(new_order, Release);
                    }
                }
            }
        }

        Ok(LOBResponse::Inserted(id, price, shares, order_type))
    }

    /// This method is supposed to remove the order from the [`LimitOrderBook`] via atomic steps.
    /// It removes the [`Order`] from the [`LimitOrderBook::omap`] and then updates the [`Limit`] node
    /// and if the [`Limit`] has been exhausted fully then it removes the [`Limit`] node from the
    /// relevant skip_list and the limit map. After this steps one final thing remains and which is updating
    /// the [`LimitOrderBook::best_ask`] or [`LimitOrderBook::best_bid`] based on the [`OrderType`] and also updating
    /// the [`OrderStatus`] of the [`Order`]. If all this things went right then the method returns the [`LOBResponse`] wrapped on [`Result::Ok`]
    /// or else returns [`LOBError`] wrapped on [`Result::Err`].
    pub fn remove_order(
        &self,
        id: String,
        price: f64,
        shares: u32,
        status: &mut OrderStatus,
    ) -> Result<LOBResponse, LOBError> {
        if let Some(tuple) = self.omap.remove(&id) {
            let order = unsafe { &*tuple.1.load(Acquire) };
            let ordered_price = OrderedFloat(order.price);
            let limit_map;
            let skip_map;
            let mut remove = false;

            match order.order_type {
                OrderType::ASK => {
                    limit_map = self.amap.clone();
                    skip_map = self.ask_list.clone();
                }
                OrderType::BID => {
                    limit_map = self.bmap.clone();
                    skip_map = self.bid_list.clone();
                }
            }

            if let Some(entry) = limit_map.get(&ordered_price) {
                if let Some(l) = unsafe { entry.value().load(Acquire).as_ref() } {
                    l.remove(tuple.1.load(Acquire), status);
                    if l.head.load(Acquire).is_null() {
                        // Remove the limit
                        skip_map.remove(&ordered_price);
                        let _ = unsafe { Box::from_raw(entry.value().load(Acquire)) };
                        remove = true;
                    }
                } else {
                    return Err(LOBError::LimitNotFound);
                }
            };

            if remove {
                limit_map.remove(&ordered_price);
            }

            match order.order_type {
                OrderType::ASK => {
                    if let Some(entry) = skip_map.front() {
                        if let Some(l) = unsafe { entry.value().load(Acquire).as_ref() } {
                            let _ = self.best_ask.compare_exchange(
                                tuple.1.load(Acquire),
                                l.head.load(Acquire),
                                Release,
                                Acquire,
                            );
                        }
                    } else {
                        self.best_ask.store(ptr::null_mut(), Release);
                    }
                }
                OrderType::BID => {
                    if let Some(entry) = skip_map.back() {
                        if let Some(l) = unsafe { entry.value().load(Acquire).as_ref() } {
                            let _ = self.best_bid.compare_exchange(
                                tuple.1.load(Acquire),
                                l.head.load(Acquire),
                                Release,
                                Acquire,
                            );
                        }
                    } else {
                        self.best_bid.store(ptr::null_mut(), Release);
                    }
                }
            }
            let ord = unsafe { Box::from_raw(tuple.1.load(Acquire)) };
            return match *status {
                OrderStatus::CANCEL => Ok(LOBResponse::Cancelled(ord)),
                OrderStatus::FULL => Ok(LOBResponse::Executed(
                    ord.id,
                    price,
                    ord.price,
                    shares,
                    OrderStatus::FULL,
                    ord.order_type,
                )),
                _ => Err(LOBError::MatchingEngineError),
            };
        }

        Err(LOBError::OrderNotFound)
    }

    /// Returns the total volume from a limit
    pub fn view_level(&self, price: f64, side: OrderType) -> Option<u32> {
        let limit_map = match side {
            OrderType::ASK => self.amap.as_ref(),
            OrderType::BID => self.bmap.as_ref(),
        };

        if let Some(l) = limit_map.get(&OrderedFloat(price)) {
            if let Some(_limit) = unsafe { l.value().load(SeqCst).as_ref() } {
                return Some(_limit.level());
            }
        }

        return None;
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crossbeam::scope;
    use std::sync::Arc;
    use std::sync::atomic::{AtomicUsize, Ordering};

    #[test]
    fn concurrent_insertions() {
        let lob = Arc::new(LimitOrderBook::new(1));
        let num_threads = 10;
        let orders_per_thread = 100_000;
        
        scope(|s| {
            for i in 0..num_threads {
                let lob = Arc::clone(&lob);
                s.spawn(move |_| {
                    for j in 0..orders_per_thread {
                        let _ = lob.insert_order(
                            format!("order_{}_{}", i, j),
                            (j % 100) as f64,
                            10,
                            OrderType::BID,
                        );
                    }
                });
            }
        })
        .unwrap();
        
        let total_orders = num_threads * orders_per_thread;
        assert_eq!(lob.omap.len(), total_orders);
    }

    #[test]
    fn concurrent_removals() {
        let lob = Arc::new(LimitOrderBook::new(1));
        let num_threads = 10;
        let orders_per_thread = 100_000;
        let mut status = OrderStatus::CANCEL;
        
        // Insert orders first
        for i in 0..num_threads {
            for j in 0..orders_per_thread {
                let _ = lob.insert_order(
                    format!("order_{}_{}", i, j),
                    (j % 100) as f64,
                    10,
                    OrderType::BID,
                );
            }
        }
        
        scope(|s| {
            for i in 0..num_threads {
                let lob = Arc::clone(&lob);
                s.spawn(move |_| {
                    for j in 0..orders_per_thread {
                        let _ = lob.remove_order(
                            format!("order_{}_{}", i, j),
                            (j % 100) as f64,
                            10,
                            &mut status,
                        );
                    }
                });
            }
        })
        .unwrap();
        
        assert_eq!(lob.omap.len(), 0);
    }
    
    #[test]
    fn million_order_stress_test() {
        let lob = Arc::new(LimitOrderBook::new(1));
        let total_orders = 1_000_000;
        let counter = Arc::new(AtomicUsize::new(0));
        
        scope(|s| {
            for i in 0..4 {
                let lob = Arc::clone(&lob);
                let counter = Arc::clone(&counter);
                s.spawn(move |_| {
                    for j in 0..total_orders / 4 {
                        let id = format!("order_{}_{}", i, j);
                        if lob.insert_order(id.clone(), (j % 100) as f64, 10, OrderType::BID).is_ok() {
                            counter.fetch_add(1, Ordering::SeqCst);
                        }
                    }
                });
            }
        })
        .unwrap();
        
        assert_eq!(counter.load(Ordering::SeqCst), total_orders);
    }
}
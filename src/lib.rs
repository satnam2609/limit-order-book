pub mod limit;
pub mod order;

use limit::*;
use order::*;
use ordered_float::OrderedFloat;
use serde::{Deserialize, Serialize};
 
 
// use std::fmt::{self, Debug};
use std::ptr::{self};
use std::sync::atomic::{AtomicI32, AtomicPtr, Ordering::*};
use std::sync::Arc;

use crossbeam_skiplist::SkipMap;
use dashmap::DashMap;

 
#[derive(Debug, Clone,Serialize,Deserialize)]
pub enum LOBResponse {
    Inserted(i32),
    Executed(i32,u32,OrderStatus),
    Cancelled(Box<Order>),
}

#[derive(Debug, Clone, Copy,Serialize,Deserialize)]
pub enum LOBError {
    InvalidOrder,
    LimitNotFound,
    OrderNotFound,
    MatchingEngineError,
}

///This struct is basically the limit order book and the data structure of the fields are concurrent skip_lists
/// [`LimitOrderBook::bid_list`] and [`LimitOrderBook::ask_list`] and dashmaps (which are the concurrent version of hashmaps)
/// [`LimitOrderBook::bmap`],[`LimitOrderBook::amap`] and [`LimitOrderBook::omap`] and the [`LimitOrderBook`] holds the pointer
/// to the [`LimitOrderBook::best_bid`] (which is the greatest limit price from the buy_list) and [`LimitOrderBook::best_ask`]
/// (which is the smallest limit price from the ask_list). This complex struct will be used by the message queue which
/// serves the job of each message by spawing new thread for specific task.
pub struct LimitOrderBook {
    pub id: i32,
    ///  Unique identification of Limit order book.
    pub sequence_counter:AtomicI32,// Sequence counter for identifying order.
    bid_list: Arc<SkipMap<OrderedFloat<f64>, AtomicPtr<Limit>>>, // tree for the ASK side.
    ask_list: Arc<SkipMap<OrderedFloat<f64>, AtomicPtr<Limit>>>, // tree for the BID side.
    bmap: Arc<DashMap<OrderedFloat<f64>, AtomicPtr<Limit>>>,     // BID type limit node's DashMap.
    amap: Arc<DashMap<OrderedFloat<f64>, AtomicPtr<Limit>>>,     // ASK type limit node's DashMap.
    omap: Arc<DashMap<i32, AtomicPtr<Order>>>, // hashmap for Orders and since order are identified using there
    // sequence number we don't need the ask and bid order's hashmap.
    pub best_bid: AtomicPtr<Order>, // atomic pointer to the best BID order.
    pub best_ask: AtomicPtr<Order>, // atomic pointer to the best ASK order.
}

impl LimitOrderBook {
    pub fn new(id: i32) -> LimitOrderBook {
        LimitOrderBook {
            id,
            sequence_counter:AtomicI32::new(0),
            bid_list: Arc::new(SkipMap::new()),
            ask_list: Arc::new(SkipMap::new()),
            bmap: Arc::new(DashMap::new()),
            amap: Arc::new(DashMap::new()),
            omap: Arc::new(DashMap::new()),
            best_bid: AtomicPtr::new(ptr::null_mut()),
            best_ask: AtomicPtr::new(ptr::null_mut()),
        }
    }

     
    /// This method is supposed to insert the [`Order`] via atomic steps.
    /// First of all the order needs the [`Order::seqeunce`] which is generated by the [`LimitOrderBook::sequence_counter`] and then 
    /// if the order is not present already in the [`LimitOrderBook::omap`] then and then only the new order is inserted.
    /// Once the order is inserted in the [`LimitOrderBook::omap`] and the relavent skip list , i.e [`LimitOrderBook::bid_list`] or [`LimitOrderBook::ask_list`]
    /// which is decided based on the [`OrderType`]. So after this step one final thing remains which is updating the [`LimitOrderBook::best_bid`] or [`LimitOrderBook::best_ask`]
    /// based on the [`OrderType`] and if anything went wrong then this method returns [`LOBError`] wrapped on the [`Result::Err`] enum , else it returns [`LOBResponse`] as an [`Result::Ok`]
    pub fn insert_order(
        &self,
        // seq: i32,
        price: f64,
        shares: u32,
        order_type: OrderType,
    ) -> Result<LOBResponse, LOBError> {
        let seq=self.sequence_counter.fetch_add(1, AcqRel);
        let new_order = Box::into_raw(Box::new(Order::new(seq, order_type, price, shares)));
        let (map, list);

        if self.omap.contains_key(&seq) {
            return Err(LOBError::InvalidOrder);
        }

        match order_type {
            OrderType::BID => {
                map = self.bmap.clone();
                list = self.bid_list.clone();
            }
            OrderType::ASK => {
                map = self.amap.clone();
                list = self.ask_list.clone();
            }
        }

        let limit = map
            .entry(OrderedFloat(price))
            .or_insert_with(|| {
                let limit = Box::into_raw(Box::new(Limit::new(price, order_type)));
                list.insert(OrderedFloat(price), AtomicPtr::new(limit));
                AtomicPtr::new(limit)
            })
            .load(SeqCst);

        if let Some(limit) = unsafe { limit.as_ref() } {
            limit.insert(new_order);
            limit.volume.fetch_add(shares, SeqCst);
        }

        self.omap.insert(seq, AtomicPtr::new(new_order));

        match order_type {
            OrderType::BID => {
                if let Err(existing_order) =
                    self.best_bid
                        .compare_exchange(ptr::null_mut(), new_order, Release, Acquire)
                {
                    if unsafe { &*existing_order }.price < price {
                        self.best_bid.store(new_order, Release);
                    }
                }
            }
            _ => {
                if let Err(existing_order) =
                    self.best_ask
                        .compare_exchange(ptr::null_mut(), new_order, Release, Acquire)
                {
                    if unsafe { &*existing_order }.price > price {
                        self.best_ask.store(new_order, Release);
                    }
                }
            }
        }

        Ok(LOBResponse::Inserted(seq))
    }

    /// This method is supposed to remove the order from the [`LimitOrderBook`] via atomic steps.
    /// It removes the [`Order`] from the [`LimitOrderBook::omap`] and then updates the [`Limit`] node 
    /// and if the [`Limit`] has been exhausted fully then it removes the [`Limit`] node from the 
    /// relevant skip_list and the limit map. After this steps one final thing remains and which is updating
    /// the [`LimitOrderBook::best_ask`] or [`LimitOrderBook::best_bid`] based on the [`OrderType`] and also updating
    /// the [`OrderStatus`] of the [`Order`]. If all this things went right then the method returns the [`LOBResponse`] wrapped on [`Result::Ok`]
    /// or else returns [`LOBError`] wrapped on [`Result::Err`].
    pub fn remove_order(
        &self,
        seq: i32,
        shares: u32,
        status: &mut OrderStatus,
    ) -> Result<LOBResponse, LOBError> {
        if let Some(tuple) = self.omap.remove(&seq) {       
            let order = unsafe { &*tuple.1.load(Acquire) };
            let ordered_price = OrderedFloat(order.price);
            let limit_map;
            let skip_map;
            let mut remove = false;

            match order.order_type {
                OrderType::ASK => {
                    limit_map = self.amap.clone();
                    skip_map = self.ask_list.clone();
                }
                OrderType::BID => {
                    limit_map = self.bmap.clone();
                    skip_map = self.bid_list.clone();
                }
            }

            if let Some(entry) = limit_map.get(&ordered_price) {
                if let Some(l) = unsafe { entry.value().load(Acquire).as_ref() } {
                    l.remove(tuple.1.load(Acquire), status);
                    if l.head.load(Acquire).is_null() {
                        // Remove the limit
                        skip_map.remove(&ordered_price);
                        let _ = unsafe { Box::from_raw(entry.value().load(Acquire)) };
                        remove = true;
                    }
                } else {
                    return Err(LOBError::LimitNotFound);
                }
            };

            if remove {
                limit_map.remove(&ordered_price);
            }

            match order.order_type {
                OrderType::ASK => {
                    if let Some(entry) = skip_map.front() {
                        if let Some(l) = unsafe { entry.value().load(Acquire).as_ref() } {
                            let _ = self.best_ask.compare_exchange(
                                tuple.1.load(Acquire),
                                l.head.load(Acquire),
                                Release,
                                Acquire,
                            );
                        }
                    }
                    else{
                        self.best_ask.store(ptr::null_mut(), Release);
                    }
                }
                OrderType::BID => {
                    if let Some(entry) = skip_map.back() {
                        if let Some(l) = unsafe { entry.value().load(Acquire).as_ref() } {
                            let _ = self.best_bid.compare_exchange(
                                tuple.1.load(Acquire),
                                l.head.load(Acquire),
                                Release,
                                Acquire,
                            );
                        }
                    }
                    else{
                        self.best_bid.store(ptr::null_mut(), Release);
                    }
                }
            }
            let ord = unsafe { Box::from_raw(tuple.1.load(Acquire)) };
            return match *status {
                OrderStatus::CANCEL => Ok(LOBResponse::Cancelled(ord)),
                OrderStatus::FULL => Ok(LOBResponse::Executed(seq,shares,OrderStatus::FULL)),
                _ => Err(LOBError::MatchingEngineError),
            };
        }

        Err(LOBError::OrderNotFound)
    }
}

#[cfg(test)]
mod tests {

    use super::*;
    use core::f64;
    use std::sync::atomic::AtomicI32;

    use std::sync::Arc;
    use std::thread;
    use std::time::Instant;

    fn get_arc_lob(id: i32) -> Arc<LimitOrderBook> {
        Arc::new(LimitOrderBook::new(id))
    }

    #[test]
    fn test_insertions() {
        let lob = get_arc_lob(1);

        let num_threads: i32 = 10;
        let orders_per_threads = 100_000;

        let counter = &AtomicI32::new(0);
        let start_time = Instant::now();
        thread::scope(|s| {
            for _ in 0..num_threads {
                let lob_clone = lob.clone();
                s.spawn(move || {
                    for _ in 0..orders_per_threads {
                        let seq = counter.fetch_add(1, AcqRel);
                        let price = 100.0 + (seq as f64) % 50.0;
                        let shares = 10 + (seq as u32) % 5;
                        let order_type = OrderType::BID;
                        let res = lob_clone.insert_order(price, shares, order_type);
                        assert!(res.is_ok());
                    }
                });
            }
        });

        dbg!("Completion time is :");
        dbg!(start_time.elapsed().as_secs_f64());

        let bid_list = lob.bid_list.clone();
        dbg!(bid_list.len());

        unsafe {
            if let Some(order) = lob.best_bid.load(Acquire).as_ref() {
                assert!(
                    order.price <= 149.0,
                    "Wrong price was selected under Best BID case"
                );
            }
        }
    }

    #[test]
    fn remove_order() {
        let lob = get_arc_lob(1);

        let initial_orders = vec![
            (0, 100.0, 10),
            (1, 101.0, 10),
            (2, 100.0, 10),
            (3, 100.0, 10),
        ];

        for (_, price, shares) in initial_orders.iter() {
            let res = lob.insert_order( *price, *shares, OrderType::BID);
            assert!(res.is_ok());
        }

        let best_bid = lob.best_bid.load(Acquire);
        assert!(!best_bid.is_null());
        if let Some(order) = unsafe { best_bid.as_ref() } {
            assert!(order.seqeunce == 1, "Incorrect order setted as Best BID");
        }

        let res = lob.remove_order(1,0, &mut OrderStatus::CANCEL);
        assert!(res.is_ok());

        assert!(lob.omap.get(&1).is_none());
        assert!(lob.bid_list.get(&OrderedFloat(101.0)).is_none());
        assert!(lob.bmap.get(&OrderedFloat(101.0)).is_none());

        let best_bid = lob.best_bid.load(Acquire);
        assert!(!best_bid.is_null());
        if let Some(order) = unsafe { best_bid.as_ref() } {
            assert!(order.seqeunce == 0, "Incorrect order setted as Best BID");
        }

        let res = lob.remove_order(2,0, &mut OrderStatus::CANCEL);
        assert!(res.is_ok());

        assert!(lob.omap.get(&2).is_none());
        assert!(lob.bid_list.get(&OrderedFloat(100.0)).is_some());
        assert!(lob.bmap.get(&OrderedFloat(100.0)).is_some());

        let best_bid = lob.best_bid.load(Acquire);
        assert!(!best_bid.is_null());
        if let Some(order) = unsafe { best_bid.as_ref() } {
            assert!(order.seqeunce == 0, "Incorrect order setted as Best BID");
        }
    }


    #[test]
    fn test_removal(){
        let lob=get_arc_lob(1);

        let initial_orders=[
            (0,102.50,100,OrderType::ASK),
            (1,102.10,100,OrderType::ASK),
            (2,102.00,100,OrderType::ASK),
            (3,101.50,100,OrderType::BID),
            (4,101.10,100,OrderType::BID),
            (5,101.00,100,OrderType::BID),
        ];
        

        for (_, price, shares,otype) in initial_orders.iter() {
            let res = lob.insert_order(  *price, *shares, *otype);
            assert!(res.is_ok());
        }

        if let Some(best_ask_price)=unsafe{lob.best_ask.load(Acquire).as_ref()}{
            assert_eq!(best_ask_price.price,102.00);
            assert!(best_ask_price.seqeunce==2);
        }

        if let Some(best_bid_price)=unsafe{lob.best_bid.load(Acquire).as_ref()}{
            assert!(best_bid_price.price==101.50);
            assert!(best_bid_price.seqeunce==3);
        }

        let res=lob.remove_order(4,0, &mut OrderStatus::CANCEL);
        assert!(res.is_ok());
        
        if let Some(best_bid_price)=unsafe{lob.best_bid.load(Acquire).as_ref()}{
            assert!(best_bid_price.price==101.50);
            assert!(best_bid_price.seqeunce==3);
        }

        
    }
}
